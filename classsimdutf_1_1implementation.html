<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdutf: simdutf::implementation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdutf
   &#160;<span id="projectnumber">3.2.15</span>
   </div>
   <div id="projectbrief">Unicode at GB/s.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsimdutf_1_1implementation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsimdutf_1_1implementation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">simdutf::implementation Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An implementation of simdutf for a particular CPU architecture.  
 <a href="classsimdutf_1_1implementation.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3281cf45b997303c89cf2d462d85d384"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3281cf45b997303c89cf2d462d85d384">name</a> () const</td></tr>
<tr class="memdesc:a3281cf45b997303c89cf2d462d85d384"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of this implementation.  <a href="classsimdutf_1_1implementation.html#a3281cf45b997303c89cf2d462d85d384">More...</a><br /></td></tr>
<tr class="separator:a3281cf45b997303c89cf2d462d85d384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147dfc3a2a525074a863374ea9ea8c09"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a147dfc3a2a525074a863374ea9ea8c09">description</a> () const</td></tr>
<tr class="memdesc:a147dfc3a2a525074a863374ea9ea8c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The description of this implementation.  <a href="classsimdutf_1_1implementation.html#a147dfc3a2a525074a863374ea9ea8c09">More...</a><br /></td></tr>
<tr class="separator:a147dfc3a2a525074a863374ea9ea8c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd8f7d8787c76e690ed9c4151abb7a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6cd8f7d8787c76e690ed9c4151abb7a9">supported_by_runtime_system</a> () const</td></tr>
<tr class="memdesc:a6cd8f7d8787c76e690ed9c4151abb7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The instruction sets this implementation is compiled against and the current CPU match.  <a href="classsimdutf_1_1implementation.html#a6cd8f7d8787c76e690ed9c4151abb7a9">More...</a><br /></td></tr>
<tr class="separator:a6cd8f7d8787c76e690ed9c4151abb7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd306a0bc3e221964af3f31a64784b12"><td class="memItemLeft" align="right" valign="top">virtual encoding_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#afd306a0bc3e221964af3f31a64784b12">autodetect_encoding</a> (const char *input, size_t length) const noexcept</td></tr>
<tr class="memdesc:afd306a0bc3e221964af3f31a64784b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will try to detect the encoding.  <a href="classsimdutf_1_1implementation.html#afd306a0bc3e221964af3f31a64784b12">More...</a><br /></td></tr>
<tr class="separator:afd306a0bc3e221964af3f31a64784b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a7dbe2fbc9d03da2542c07a88cdddb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ad4a7dbe2fbc9d03da2542c07a88cdddb">detect_encodings</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:ad4a7dbe2fbc9d03da2542c07a88cdddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will try to detect the possible encodings in one pass.  <a href="classsimdutf_1_1implementation.html#ad4a7dbe2fbc9d03da2542c07a88cdddb">More...</a><br /></td></tr>
<tr class="separator:ad4a7dbe2fbc9d03da2542c07a88cdddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae969eb20db2099f92a504eb7db0bcf"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aaae969eb20db2099f92a504eb7db0bcf">validate_utf8</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:aaae969eb20db2099f92a504eb7db0bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-8 string.  <a href="classsimdutf_1_1implementation.html#aaae969eb20db2099f92a504eb7db0bcf">More...</a><br /></td></tr>
<tr class="separator:aaae969eb20db2099f92a504eb7db0bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f53d3a9e9112a7ad4dfe67cfeccf07"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a42f53d3a9e9112a7ad4dfe67cfeccf07">validate_utf8_with_errors</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a42f53d3a9e9112a7ad4dfe67cfeccf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-8 string and stop on errors.  <a href="classsimdutf_1_1implementation.html#a42f53d3a9e9112a7ad4dfe67cfeccf07">More...</a><br /></td></tr>
<tr class="separator:a42f53d3a9e9112a7ad4dfe67cfeccf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde94939db547675113aa71ec979d2ce"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#adde94939db547675113aa71ec979d2ce">validate_ascii</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:adde94939db547675113aa71ec979d2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the ASCII string.  <a href="classsimdutf_1_1implementation.html#adde94939db547675113aa71ec979d2ce">More...</a><br /></td></tr>
<tr class="separator:adde94939db547675113aa71ec979d2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e0b4e751f59a6f67c0bde3e503e23"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aa73e0b4e751f59a6f67c0bde3e503e23">validate_ascii_with_errors</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:aa73e0b4e751f59a6f67c0bde3e503e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the ASCII string and stop on error.  <a href="classsimdutf_1_1implementation.html#aa73e0b4e751f59a6f67c0bde3e503e23">More...</a><br /></td></tr>
<tr class="separator:aa73e0b4e751f59a6f67c0bde3e503e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6047ac139bd2e8f6808a5bbd4b687629"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6047ac139bd2e8f6808a5bbd4b687629">validate_utf16le</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a6047ac139bd2e8f6808a5bbd4b687629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16LE string.This function may be best when you expect the input to be almost always valid.  <a href="classsimdutf_1_1implementation.html#a6047ac139bd2e8f6808a5bbd4b687629">More...</a><br /></td></tr>
<tr class="separator:a6047ac139bd2e8f6808a5bbd4b687629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a221cf4c4d195d110387d10bbd4b33"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a27a221cf4c4d195d110387d10bbd4b33">validate_utf16be</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a27a221cf4c4d195d110387d10bbd4b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a27a221cf4c4d195d110387d10bbd4b33">More...</a><br /></td></tr>
<tr class="separator:a27a221cf4c4d195d110387d10bbd4b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ce751bb24df472a93e4c36e8a1b03d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a53ce751bb24df472a93e4c36e8a1b03d">validate_utf16le_with_errors</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a53ce751bb24df472a93e4c36e8a1b03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16LE string and stop on error.  <a href="classsimdutf_1_1implementation.html#a53ce751bb24df472a93e4c36e8a1b03d">More...</a><br /></td></tr>
<tr class="separator:a53ce751bb24df472a93e4c36e8a1b03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7632c87e825c7f268cbb787612e940bf"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a7632c87e825c7f268cbb787612e940bf">validate_utf16be_with_errors</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a7632c87e825c7f268cbb787612e940bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16BE string and stop on error.  <a href="classsimdutf_1_1implementation.html#a7632c87e825c7f268cbb787612e940bf">More...</a><br /></td></tr>
<tr class="separator:a7632c87e825c7f268cbb787612e940bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35c6765b2e4b97cc97ab9f3af52c9a9"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ab35c6765b2e4b97cc97ab9f3af52c9a9">validate_utf32</a> (const char32_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:ab35c6765b2e4b97cc97ab9f3af52c9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-32 string.  <a href="classsimdutf_1_1implementation.html#ab35c6765b2e4b97cc97ab9f3af52c9a9">More...</a><br /></td></tr>
<tr class="separator:ab35c6765b2e4b97cc97ab9f3af52c9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825ad7513447a16cd12f5425e2e88431"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a825ad7513447a16cd12f5425e2e88431">validate_utf32_with_errors</a> (const char32_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a825ad7513447a16cd12f5425e2e88431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-32 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a825ad7513447a16cd12f5425e2e88431">More...</a><br /></td></tr>
<tr class="separator:a825ad7513447a16cd12f5425e2e88431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79deb79661a71f145b7bc6786fe4223"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#af79deb79661a71f145b7bc6786fe4223">convert_latin1_to_utf8</a> (const char *input, size_t length, char *utf8_output) const noexcept=0</td></tr>
<tr class="memdesc:af79deb79661a71f145b7bc6786fe4223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Latin1 string into UTF8 string.  <a href="classsimdutf_1_1implementation.html#af79deb79661a71f145b7bc6786fe4223">More...</a><br /></td></tr>
<tr class="separator:af79deb79661a71f145b7bc6786fe4223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2315da3daf654f4a7132b1751394b374"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2315da3daf654f4a7132b1751394b374">convert_latin1_to_utf16le</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a2315da3daf654f4a7132b1751394b374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly Latin1 string into UTF-16LE string.  <a href="classsimdutf_1_1implementation.html#a2315da3daf654f4a7132b1751394b374">More...</a><br /></td></tr>
<tr class="separator:a2315da3daf654f4a7132b1751394b374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f498ad9236b916e5e4859109d1df0bb"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2f498ad9236b916e5e4859109d1df0bb">convert_latin1_to_utf16be</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a2f498ad9236b916e5e4859109d1df0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Latin1 string into UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a2f498ad9236b916e5e4859109d1df0bb">More...</a><br /></td></tr>
<tr class="separator:a2f498ad9236b916e5e4859109d1df0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb5a0db793a6e332711c24d9cbc14fd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5bb5a0db793a6e332711c24d9cbc14fd">convert_latin1_to_utf32</a> (const char *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a5bb5a0db793a6e332711c24d9cbc14fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Latin1 string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#a5bb5a0db793a6e332711c24d9cbc14fd">More...</a><br /></td></tr>
<tr class="separator:a5bb5a0db793a6e332711c24d9cbc14fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c2c1418f08f84e36c22727879db307"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ac9c2c1418f08f84e36c22727879db307">convert_utf8_to_latin1</a> (const char *input, size_t length, char *latin1_output) const noexcept=0</td></tr>
<tr class="memdesc:ac9c2c1418f08f84e36c22727879db307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into latin1 string.  <a href="classsimdutf_1_1implementation.html#ac9c2c1418f08f84e36c22727879db307">More...</a><br /></td></tr>
<tr class="separator:ac9c2c1418f08f84e36c22727879db307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae845d016f715c25475970c4dfcb58a8d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ae845d016f715c25475970c4dfcb58a8d">convert_utf8_to_latin1_with_errors</a> (const char *input, size_t length, char *latin1_output) const noexcept=0</td></tr>
<tr class="memdesc:ae845d016f715c25475970c4dfcb58a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into latin1 string.  <a href="classsimdutf_1_1implementation.html#ae845d016f715c25475970c4dfcb58a8d">More...</a><br /></td></tr>
<tr class="separator:ae845d016f715c25475970c4dfcb58a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903279159cb5f5e0e767cce6f1440889"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a903279159cb5f5e0e767cce6f1440889">convert_valid_utf8_to_latin1</a> (const char *input, size_t length, char *latin1_output) const noexcept=0</td></tr>
<tr class="memdesc:a903279159cb5f5e0e767cce6f1440889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into latin1 string.  <a href="classsimdutf_1_1implementation.html#a903279159cb5f5e0e767cce6f1440889">More...</a><br /></td></tr>
<tr class="separator:a903279159cb5f5e0e767cce6f1440889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487615c5d6dc00183fdf6a904bd829dc"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a487615c5d6dc00183fdf6a904bd829dc">convert_utf8_to_utf16le</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a487615c5d6dc00183fdf6a904bd829dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16LE string.  <a href="classsimdutf_1_1implementation.html#a487615c5d6dc00183fdf6a904bd829dc">More...</a><br /></td></tr>
<tr class="separator:a487615c5d6dc00183fdf6a904bd829dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb08f6b1d102dd298f3d265615b21aa"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a0eb08f6b1d102dd298f3d265615b21aa">convert_utf8_to_utf16be</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a0eb08f6b1d102dd298f3d265615b21aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a0eb08f6b1d102dd298f3d265615b21aa">More...</a><br /></td></tr>
<tr class="separator:a0eb08f6b1d102dd298f3d265615b21aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6091f1fbcaf897575af907ab8896d151"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6091f1fbcaf897575af907ab8896d151">convert_utf8_to_utf16le_with_errors</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a6091f1fbcaf897575af907ab8896d151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16LE string and stop on error.  <a href="classsimdutf_1_1implementation.html#a6091f1fbcaf897575af907ab8896d151">More...</a><br /></td></tr>
<tr class="separator:a6091f1fbcaf897575af907ab8896d151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18e1b44673966d2f058524700d41db0"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ae18e1b44673966d2f058524700d41db0">convert_utf8_to_utf16be_with_errors</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:ae18e1b44673966d2f058524700d41db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16BE string and stop on error.  <a href="classsimdutf_1_1implementation.html#ae18e1b44673966d2f058524700d41db0">More...</a><br /></td></tr>
<tr class="separator:ae18e1b44673966d2f058524700d41db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab894ce236190e9cc71e0ce1602bbc60"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aab894ce236190e9cc71e0ce1602bbc60">convert_utf8_to_utf32</a> (const char *input, size_t length, char32_t *utf32_output) const noexcept=0</td></tr>
<tr class="memdesc:aab894ce236190e9cc71e0ce1602bbc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#aab894ce236190e9cc71e0ce1602bbc60">More...</a><br /></td></tr>
<tr class="separator:aab894ce236190e9cc71e0ce1602bbc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5166f22c16902452eec6a93ad7a926"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5c5166f22c16902452eec6a93ad7a926">convert_utf8_to_utf32_with_errors</a> (const char *input, size_t length, char32_t *utf32_output) const noexcept=0</td></tr>
<tr class="memdesc:a5c5166f22c16902452eec6a93ad7a926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-32 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a5c5166f22c16902452eec6a93ad7a926">More...</a><br /></td></tr>
<tr class="separator:a5c5166f22c16902452eec6a93ad7a926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08870586c80a46861a25c715323402c1"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a08870586c80a46861a25c715323402c1">convert_valid_utf8_to_utf16le</a> (const char *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a08870586c80a46861a25c715323402c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into UTF-16LE string.  <a href="classsimdutf_1_1implementation.html#a08870586c80a46861a25c715323402c1">More...</a><br /></td></tr>
<tr class="separator:a08870586c80a46861a25c715323402c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d655f7769c5e5039821d512c116dc56"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a8d655f7769c5e5039821d512c116dc56">convert_valid_utf8_to_utf16be</a> (const char *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a8d655f7769c5e5039821d512c116dc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a8d655f7769c5e5039821d512c116dc56">More...</a><br /></td></tr>
<tr class="separator:a8d655f7769c5e5039821d512c116dc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7566c1718e91a6d36b0c47822b0154ad"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a7566c1718e91a6d36b0c47822b0154ad">convert_valid_utf8_to_utf32</a> (const char *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a7566c1718e91a6d36b0c47822b0154ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#a7566c1718e91a6d36b0c47822b0154ad">More...</a><br /></td></tr>
<tr class="separator:a7566c1718e91a6d36b0c47822b0154ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01141d4bf774c95e771924caa11efb1"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ae01141d4bf774c95e771924caa11efb1">utf16_length_from_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:ae01141d4bf774c95e771924caa11efb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of 2-byte code units that this UTF-8 string would require in UTF-16LE format.  <a href="classsimdutf_1_1implementation.html#ae01141d4bf774c95e771924caa11efb1">More...</a><br /></td></tr>
<tr class="separator:ae01141d4bf774c95e771924caa11efb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bc047dd50ede9cd33cb7e825eb5b56"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a39bc047dd50ede9cd33cb7e825eb5b56">utf32_length_from_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a39bc047dd50ede9cd33cb7e825eb5b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of 4-byte code units that this UTF-8 string would require in UTF-32 format.  <a href="classsimdutf_1_1implementation.html#a39bc047dd50ede9cd33cb7e825eb5b56">More...</a><br /></td></tr>
<tr class="separator:a39bc047dd50ede9cd33cb7e825eb5b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f16dc0f3bdd4457425898a17c51d45"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a75f16dc0f3bdd4457425898a17c51d45">convert_utf16le_to_latin1</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a75f16dc0f3bdd4457425898a17c51d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into Latin1 string.  <a href="classsimdutf_1_1implementation.html#a75f16dc0f3bdd4457425898a17c51d45">More...</a><br /></td></tr>
<tr class="separator:a75f16dc0f3bdd4457425898a17c51d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac941440407fed1518a179f1d0396720c"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ac941440407fed1518a179f1d0396720c">convert_utf16be_to_latin1</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ac941440407fed1518a179f1d0396720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into Latin1 string.  <a href="classsimdutf_1_1implementation.html#ac941440407fed1518a179f1d0396720c">More...</a><br /></td></tr>
<tr class="separator:ac941440407fed1518a179f1d0396720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa4c4b831e691e623552bbf9c60b801"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a4aa4c4b831e691e623552bbf9c60b801">convert_utf16le_to_latin1_with_errors</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a4aa4c4b831e691e623552bbf9c60b801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into Latin1 string.  <a href="classsimdutf_1_1implementation.html#a4aa4c4b831e691e623552bbf9c60b801">More...</a><br /></td></tr>
<tr class="separator:a4aa4c4b831e691e623552bbf9c60b801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a8022ac1760f081d389cb00a4dac80"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a29a8022ac1760f081d389cb00a4dac80">convert_utf16be_to_latin1_with_errors</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a29a8022ac1760f081d389cb00a4dac80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into Latin1 string.  <a href="classsimdutf_1_1implementation.html#a29a8022ac1760f081d389cb00a4dac80">More...</a><br /></td></tr>
<tr class="separator:a29a8022ac1760f081d389cb00a4dac80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c8a9e58f4c111d52851e4fdbca0af1"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a65c8a9e58f4c111d52851e4fdbca0af1">convert_valid_utf16le_to_latin1</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a65c8a9e58f4c111d52851e4fdbca0af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into Latin1 string.  <a href="classsimdutf_1_1implementation.html#a65c8a9e58f4c111d52851e4fdbca0af1">More...</a><br /></td></tr>
<tr class="separator:a65c8a9e58f4c111d52851e4fdbca0af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6896e27fd7fe773ba25bfaed081aafaa"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6896e27fd7fe773ba25bfaed081aafaa">convert_valid_utf16be_to_latin1</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a6896e27fd7fe773ba25bfaed081aafaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16BE string into Latin1 string.  <a href="classsimdutf_1_1implementation.html#a6896e27fd7fe773ba25bfaed081aafaa">More...</a><br /></td></tr>
<tr class="separator:a6896e27fd7fe773ba25bfaed081aafaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca86864832acad7c1277e6675c73e58"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#abca86864832acad7c1277e6675c73e58">convert_utf16le_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:abca86864832acad7c1277e6675c73e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#abca86864832acad7c1277e6675c73e58">More...</a><br /></td></tr>
<tr class="separator:abca86864832acad7c1277e6675c73e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4694517e0f22276fea37d154e35648e4"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a4694517e0f22276fea37d154e35648e4">convert_utf16be_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a4694517e0f22276fea37d154e35648e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#a4694517e0f22276fea37d154e35648e4">More...</a><br /></td></tr>
<tr class="separator:a4694517e0f22276fea37d154e35648e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cb2f67aadb85bb3c64789f3d501d8b"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a77cb2f67aadb85bb3c64789f3d501d8b">convert_utf16le_to_utf8_with_errors</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a77cb2f67aadb85bb3c64789f3d501d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-8 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a77cb2f67aadb85bb3c64789f3d501d8b">More...</a><br /></td></tr>
<tr class="separator:a77cb2f67aadb85bb3c64789f3d501d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558db3f984286ccd44517a622f8cd676"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a558db3f984286ccd44517a622f8cd676">convert_utf16be_to_utf8_with_errors</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a558db3f984286ccd44517a622f8cd676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-8 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a558db3f984286ccd44517a622f8cd676">More...</a><br /></td></tr>
<tr class="separator:a558db3f984286ccd44517a622f8cd676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5ab12b92ea57e2b88af5b19118833b"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3d5ab12b92ea57e2b88af5b19118833b">convert_valid_utf16le_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a3d5ab12b92ea57e2b88af5b19118833b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#a3d5ab12b92ea57e2b88af5b19118833b">More...</a><br /></td></tr>
<tr class="separator:a3d5ab12b92ea57e2b88af5b19118833b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204aff56bf36d384694a5b5e73ddc579"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a204aff56bf36d384694a5b5e73ddc579">convert_valid_utf16be_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a204aff56bf36d384694a5b5e73ddc579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16BE string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#a204aff56bf36d384694a5b5e73ddc579">More...</a><br /></td></tr>
<tr class="separator:a204aff56bf36d384694a5b5e73ddc579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcdaa10985d51cd8f533c41d03c7ce0"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a0fcdaa10985d51cd8f533c41d03c7ce0">convert_utf16le_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a0fcdaa10985d51cd8f533c41d03c7ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#a0fcdaa10985d51cd8f533c41d03c7ce0">More...</a><br /></td></tr>
<tr class="separator:a0fcdaa10985d51cd8f533c41d03c7ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6297479226621edb24ffc30d642083d5"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6297479226621edb24ffc30d642083d5">convert_utf16be_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a6297479226621edb24ffc30d642083d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#a6297479226621edb24ffc30d642083d5">More...</a><br /></td></tr>
<tr class="separator:a6297479226621edb24ffc30d642083d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53d42cf1525497c67690667242b669d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ab53d42cf1525497c67690667242b669d">convert_utf16le_to_utf32_with_errors</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ab53d42cf1525497c67690667242b669d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-32 string and stop on error.  <a href="classsimdutf_1_1implementation.html#ab53d42cf1525497c67690667242b669d">More...</a><br /></td></tr>
<tr class="separator:ab53d42cf1525497c67690667242b669d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f306f07f9b0c88646629efc7672bfd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a78f306f07f9b0c88646629efc7672bfd">convert_utf16be_to_utf32_with_errors</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a78f306f07f9b0c88646629efc7672bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-32 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a78f306f07f9b0c88646629efc7672bfd">More...</a><br /></td></tr>
<tr class="separator:a78f306f07f9b0c88646629efc7672bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd5db8c4f3f4b6055497138f8cec860"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2bd5db8c4f3f4b6055497138f8cec860">convert_valid_utf16le_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a2bd5db8c4f3f4b6055497138f8cec860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#a2bd5db8c4f3f4b6055497138f8cec860">More...</a><br /></td></tr>
<tr class="separator:a2bd5db8c4f3f4b6055497138f8cec860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e91ad7be0d09f713283d33105a4939"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a15e91ad7be0d09f713283d33105a4939">convert_valid_utf16be_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a15e91ad7be0d09f713283d33105a4939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into UTF-32BE string.  <a href="classsimdutf_1_1implementation.html#a15e91ad7be0d09f713283d33105a4939">More...</a><br /></td></tr>
<tr class="separator:a15e91ad7be0d09f713283d33105a4939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446248e71fc872b071d25a27673139f5"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a446248e71fc872b071d25a27673139f5">utf8_length_from_utf16le</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a446248e71fc872b071d25a27673139f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-16LE string would require in UTF-8 format.  <a href="classsimdutf_1_1implementation.html#a446248e71fc872b071d25a27673139f5">More...</a><br /></td></tr>
<tr class="separator:a446248e71fc872b071d25a27673139f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce2ef1ff8ab5ffd3999d545f703a2fd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#abce2ef1ff8ab5ffd3999d545f703a2fd">utf8_length_from_utf16be</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:abce2ef1ff8ab5ffd3999d545f703a2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-16BE string would require in UTF-8 format.  <a href="classsimdutf_1_1implementation.html#abce2ef1ff8ab5ffd3999d545f703a2fd">More...</a><br /></td></tr>
<tr class="separator:abce2ef1ff8ab5ffd3999d545f703a2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c1ec7808c2572670b540cd3ccce6b1"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a66c1ec7808c2572670b540cd3ccce6b1">convert_utf32_to_latin1</a> (const char32_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a66c1ec7808c2572670b540cd3ccce6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into Latin1 string.  <a href="classsimdutf_1_1implementation.html#a66c1ec7808c2572670b540cd3ccce6b1">More...</a><br /></td></tr>
<tr class="separator:a66c1ec7808c2572670b540cd3ccce6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d067614ecf86f2e7a6dfa2158567677"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2d067614ecf86f2e7a6dfa2158567677">convert_utf32_to_latin1_with_errors</a> (const char32_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a2d067614ecf86f2e7a6dfa2158567677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into Latin1 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a2d067614ecf86f2e7a6dfa2158567677">More...</a><br /></td></tr>
<tr class="separator:a2d067614ecf86f2e7a6dfa2158567677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b1ec570f19982c826e2b04b501a1ac"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a00b1ec570f19982c826e2b04b501a1ac">convert_valid_utf32_to_latin1</a> (const char32_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a00b1ec570f19982c826e2b04b501a1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into Latin1 string.  <a href="classsimdutf_1_1implementation.html#a00b1ec570f19982c826e2b04b501a1ac">More...</a><br /></td></tr>
<tr class="separator:a00b1ec570f19982c826e2b04b501a1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba1394d1cb70ff61ff9e10fec2b4ae"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ac5ba1394d1cb70ff61ff9e10fec2b4ae">convert_utf32_to_utf8</a> (const char32_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ac5ba1394d1cb70ff61ff9e10fec2b4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#ac5ba1394d1cb70ff61ff9e10fec2b4ae">More...</a><br /></td></tr>
<tr class="separator:ac5ba1394d1cb70ff61ff9e10fec2b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad868e852d46a46b631524f2a4bb5f31d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ad868e852d46a46b631524f2a4bb5f31d">convert_utf32_to_utf8_with_errors</a> (const char32_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ad868e852d46a46b631524f2a4bb5f31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-8 string and stop on error.  <a href="classsimdutf_1_1implementation.html#ad868e852d46a46b631524f2a4bb5f31d">More...</a><br /></td></tr>
<tr class="separator:ad868e852d46a46b631524f2a4bb5f31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d859ac6b4327e3155f1accef2f42c23"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5d859ac6b4327e3155f1accef2f42c23">convert_valid_utf32_to_utf8</a> (const char32_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a5d859ac6b4327e3155f1accef2f42c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#a5d859ac6b4327e3155f1accef2f42c23">More...</a><br /></td></tr>
<tr class="separator:a5d859ac6b4327e3155f1accef2f42c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b211eefd837bfb9c080df56c408c3d4"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a4b211eefd837bfb9c080df56c408c3d4">utf16_length_from_latin1</a> (size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a4b211eefd837bfb9c080df56c408c3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that this UTF-16 string would require in Latin1 format.  <a href="classsimdutf_1_1implementation.html#a4b211eefd837bfb9c080df56c408c3d4">More...</a><br /></td></tr>
<tr class="separator:a4b211eefd837bfb9c080df56c408c3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342d098f7c92e8344944dfa947daa66d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a342d098f7c92e8344944dfa947daa66d">convert_utf32_to_utf16le</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a342d098f7c92e8344944dfa947daa66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16LE string.  <a href="classsimdutf_1_1implementation.html#a342d098f7c92e8344944dfa947daa66d">More...</a><br /></td></tr>
<tr class="separator:a342d098f7c92e8344944dfa947daa66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f90a3a4b12a2e361618fb3e9e4b5cbd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a7f90a3a4b12a2e361618fb3e9e4b5cbd">convert_utf32_to_utf16be</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a7f90a3a4b12a2e361618fb3e9e4b5cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a7f90a3a4b12a2e361618fb3e9e4b5cbd">More...</a><br /></td></tr>
<tr class="separator:a7f90a3a4b12a2e361618fb3e9e4b5cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af760d6a771de56c57588241cb01b597f"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#af760d6a771de56c57588241cb01b597f">convert_utf32_to_utf16le_with_errors</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:af760d6a771de56c57588241cb01b597f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16LE string and stop on error.  <a href="classsimdutf_1_1implementation.html#af760d6a771de56c57588241cb01b597f">More...</a><br /></td></tr>
<tr class="separator:af760d6a771de56c57588241cb01b597f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eed63c72cb1a7736ecb96f149d0ae6f"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3eed63c72cb1a7736ecb96f149d0ae6f">convert_utf32_to_utf16be_with_errors</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a3eed63c72cb1a7736ecb96f149d0ae6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16BE string and stop on error.  <a href="classsimdutf_1_1implementation.html#a3eed63c72cb1a7736ecb96f149d0ae6f">More...</a><br /></td></tr>
<tr class="separator:a3eed63c72cb1a7736ecb96f149d0ae6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8ccb48c01e7f93480e9bdd7fb3beee"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a9f8ccb48c01e7f93480e9bdd7fb3beee">convert_valid_utf32_to_utf16le</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a9f8ccb48c01e7f93480e9bdd7fb3beee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into UTF-16LE string.  <a href="classsimdutf_1_1implementation.html#a9f8ccb48c01e7f93480e9bdd7fb3beee">More...</a><br /></td></tr>
<tr class="separator:a9f8ccb48c01e7f93480e9bdd7fb3beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38557c96a34c9cc87f7294aca0538582"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a38557c96a34c9cc87f7294aca0538582">convert_valid_utf32_to_utf16be</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a38557c96a34c9cc87f7294aca0538582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a38557c96a34c9cc87f7294aca0538582">More...</a><br /></td></tr>
<tr class="separator:a38557c96a34c9cc87f7294aca0538582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a342c5088a3b2887485836daa92628a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a8a342c5088a3b2887485836daa92628a">change_endianness_utf16</a> (const char16_t *input, size_t length, char16_t *output) const noexcept=0</td></tr>
<tr class="memdesc:a8a342c5088a3b2887485836daa92628a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the endianness of the input.  <a href="classsimdutf_1_1implementation.html#a8a342c5088a3b2887485836daa92628a">More...</a><br /></td></tr>
<tr class="separator:a8a342c5088a3b2887485836daa92628a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff358bb1f0b909cd1e9a6227656ee5d7"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aff358bb1f0b909cd1e9a6227656ee5d7">utf8_length_from_latin1</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:aff358bb1f0b909cd1e9a6227656ee5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that this Latin1 string would require in UTF-8 format.  <a href="classsimdutf_1_1implementation.html#aff358bb1f0b909cd1e9a6227656ee5d7">More...</a><br /></td></tr>
<tr class="separator:aff358bb1f0b909cd1e9a6227656ee5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f39ff7d49c8864a9035c626825edad0"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2f39ff7d49c8864a9035c626825edad0">utf8_length_from_utf32</a> (const char32_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a2f39ff7d49c8864a9035c626825edad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-32 string would require in UTF-8 format.  <a href="classsimdutf_1_1implementation.html#a2f39ff7d49c8864a9035c626825edad0">More...</a><br /></td></tr>
<tr class="separator:a2f39ff7d49c8864a9035c626825edad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6936dace0dfd89741259cdbe49b5df2d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6936dace0dfd89741259cdbe49b5df2d">latin1_length_from_utf32</a> (size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a6936dace0dfd89741259cdbe49b5df2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-32 string would require in Latin1 format.  <a href="classsimdutf_1_1implementation.html#a6936dace0dfd89741259cdbe49b5df2d">More...</a><br /></td></tr>
<tr class="separator:a6936dace0dfd89741259cdbe49b5df2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc04b416c87dfa742056ce5bd8033dc"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2cc04b416c87dfa742056ce5bd8033dc">latin1_length_from_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a2cc04b416c87dfa742056ce5bd8033dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-8 string would require in Latin1 format.  <a href="classsimdutf_1_1implementation.html#a2cc04b416c87dfa742056ce5bd8033dc">More...</a><br /></td></tr>
<tr class="separator:a2cc04b416c87dfa742056ce5bd8033dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aed89399b43b6f7a36172f3af38b99"><td class="memItemLeft" align="right" valign="top"><a id="a83aed89399b43b6f7a36172f3af38b99"></a>
virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><b>latin1_length_from_utf16</b> (size_t length) const noexcept=0</td></tr>
<tr class="separator:a83aed89399b43b6f7a36172f3af38b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3761299ce52ee8b2b480fcadc50b45a5"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3761299ce52ee8b2b480fcadc50b45a5">utf16_length_from_utf32</a> (const char32_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a3761299ce52ee8b2b480fcadc50b45a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of two-byte code units that this UTF-32 string would require in UTF-16 format.  <a href="classsimdutf_1_1implementation.html#a3761299ce52ee8b2b480fcadc50b45a5">More...</a><br /></td></tr>
<tr class="separator:a3761299ce52ee8b2b480fcadc50b45a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8039edd257c0f2bdf1acc5d16476992a"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a8039edd257c0f2bdf1acc5d16476992a">utf32_length_from_latin1</a> (size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a8039edd257c0f2bdf1acc5d16476992a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that this UTF-32 string would require in Latin1 format.  <a href="classsimdutf_1_1implementation.html#a8039edd257c0f2bdf1acc5d16476992a">More...</a><br /></td></tr>
<tr class="separator:a8039edd257c0f2bdf1acc5d16476992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b225db7024f73fdcd6f84fb10ecdfe"><td class="memItemLeft" align="right" valign="top"><a id="a83b225db7024f73fdcd6f84fb10ecdfe"></a>
virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><b>utf32_length_from_utf16le</b> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="separator:a83b225db7024f73fdcd6f84fb10ecdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df5efd699e928178cb569ee2b9b0711"><td class="memItemLeft" align="right" valign="top"><a id="a0df5efd699e928178cb569ee2b9b0711"></a>
virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><b>utf32_length_from_utf16be</b> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="separator:a0df5efd699e928178cb569ee2b9b0711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612381e291d6a957707defcba3c5d4aa"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a612381e291d6a957707defcba3c5d4aa">count_utf16le</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a612381e291d6a957707defcba3c5d4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of code points (characters) in the string assuming that it is valid.  <a href="classsimdutf_1_1implementation.html#a612381e291d6a957707defcba3c5d4aa">More...</a><br /></td></tr>
<tr class="separator:a612381e291d6a957707defcba3c5d4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80712666d56ad7abb7cd8ea7862a4dd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ad80712666d56ad7abb7cd8ea7862a4dd">count_utf16be</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:ad80712666d56ad7abb7cd8ea7862a4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of code points (characters) in the string assuming that it is valid.  <a href="classsimdutf_1_1implementation.html#ad80712666d56ad7abb7cd8ea7862a4dd">More...</a><br /></td></tr>
<tr class="separator:ad80712666d56ad7abb7cd8ea7862a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380f5ef4b282ef66210a84ebc84bce51"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a380f5ef4b282ef66210a84ebc84bce51">count_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a380f5ef4b282ef66210a84ebc84bce51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of code points (characters) in the string assuming that it is valid.  <a href="classsimdutf_1_1implementation.html#a380f5ef4b282ef66210a84ebc84bce51">More...</a><br /></td></tr>
<tr class="separator:a380f5ef4b282ef66210a84ebc84bce51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of simdutf for a particular CPU architecture. </p>
<p>Also used to maintain the currently active implementation. The active implementation is automatically initialized on first use to the most advanced implementation supported by the host. </p>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l01327">1327</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="afd306a0bc3e221964af3f31a64784b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd306a0bc3e221964af3f31a64784b12">&#9670;&nbsp;</a></span>autodetect_encoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual encoding_type simdutf::implementation::autodetect_encoding </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will try to detect the encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the string to identify </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoding type detected </dd></dl>

</div>
</div>
<a id="a8a342c5088a3b2887485836daa92628a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a342c5088a3b2887485836daa92628a">&#9670;&nbsp;</a></span>change_endianness_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void simdutf::implementation::change_endianness_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the endianness of the input. </p>
<p>Can be used to go from UTF-16LE to UTF-16BE or from UTF-16BE to UTF-16LE.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">output</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f498ad9236b916e5e4859109d1df0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f498ad9236b916e5e4859109d1df0bb">&#9670;&nbsp;</a></span>convert_latin1_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_latin1_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert Latin1 string into UTF-16BE string. </p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a2315da3daf654f4a7132b1751394b374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2315da3daf654f4a7132b1751394b374">&#9670;&nbsp;</a></span>convert_latin1_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_latin1_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly Latin1 string into UTF-16LE string. </p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a5bb5a0db793a6e332711c24d9cbc14fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb5a0db793a6e332711c24d9cbc14fd">&#9670;&nbsp;</a></span>convert_latin1_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_latin1_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert Latin1 string into UTF-32 string. </p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char32_t; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="af79deb79661a71f145b7bc6786fe4223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79deb79661a71f145b7bc6786fe4223">&#9670;&nbsp;</a></span>convert_latin1_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_latin1_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert Latin1 string into UTF8 string. </p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="ac941440407fed1518a179f1d0396720c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac941440407fed1518a179f1d0396720c">&#9670;&nbsp;</a></span>convert_utf16be_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16be_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into Latin1 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a29a8022ac1760f081d389cb00a4dac80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a8022ac1760f081d389cb00a4dac80">&#9670;&nbsp;</a></span>convert_utf16be_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16be_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into Latin1 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources. This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a6297479226621edb24ffc30d642083d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6297479226621edb24ffc30d642083d5">&#9670;&nbsp;</a></span>convert_utf16be_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16be_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-32 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16BE string </dd></dl>

</div>
</div>
<a id="a78f306f07f9b0c88646629efc7672bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f306f07f9b0c88646629efc7672bfd">&#9670;&nbsp;</a></span>convert_utf16be_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16be_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-32 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="a4694517e0f22276fea37d154e35648e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4694517e0f22276fea37d154e35648e4">&#9670;&nbsp;</a></span>convert_utf16be_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16be_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-8 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16BE string </dd></dl>

</div>
</div>
<a id="a558db3f984286ccd44517a622f8cd676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558db3f984286ccd44517a622f8cd676">&#9670;&nbsp;</a></span>convert_utf16be_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16be_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-8 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a75f16dc0f3bdd4457425898a17c51d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f16dc0f3bdd4457425898a17c51d45">&#9670;&nbsp;</a></span>convert_utf16le_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16le_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into Latin1 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="a4aa4c4b831e691e623552bbf9c60b801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa4c4b831e691e623552bbf9c60b801">&#9670;&nbsp;</a></span>convert_utf16le_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16le_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into Latin1 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources. This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a0fcdaa10985d51cd8f533c41d03c7ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcdaa10985d51cd8f533c41d03c7ce0">&#9670;&nbsp;</a></span>convert_utf16le_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16le_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-32 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="ab53d42cf1525497c67690667242b669d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53d42cf1525497c67690667242b669d">&#9670;&nbsp;</a></span>convert_utf16le_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16le_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-32 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="abca86864832acad7c1277e6675c73e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca86864832acad7c1277e6675c73e58">&#9670;&nbsp;</a></span>convert_utf16le_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16le_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-8 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="a77cb2f67aadb85bb3c64789f3d501d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cb2f67aadb85bb3c64789f3d501d8b">&#9670;&nbsp;</a></span>convert_utf16le_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16le_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-8 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a66c1ec7808c2572670b540cd3ccce6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c1ec7808c2572670b540cd3ccce6b1">&#9670;&nbsp;</a></span>convert_utf32_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into Latin1 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="a2d067614ecf86f2e7a6dfa2158567677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d067614ecf86f2e7a6dfa2158567677">&#9670;&nbsp;</a></span>convert_utf32_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into Latin1 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a7f90a3a4b12a2e361618fb3e9e4b5cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f90a3a4b12a2e361618fb3e9e4b5cbd">&#9670;&nbsp;</a></span>convert_utf32_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16BE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="a3eed63c72cb1a7736ecb96f149d0ae6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eed63c72cb1a7736ecb96f149d0ae6f">&#9670;&nbsp;</a></span>convert_utf32_to_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16BE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="a342d098f7c92e8344944dfa947daa66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342d098f7c92e8344944dfa947daa66d">&#9670;&nbsp;</a></span>convert_utf32_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16LE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="af760d6a771de56c57588241cb01b597f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af760d6a771de56c57588241cb01b597f">&#9670;&nbsp;</a></span>convert_utf32_to_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16LE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="ac5ba1394d1cb70ff61ff9e10fec2b4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ba1394d1cb70ff61ff9e10fec2b4ae">&#9670;&nbsp;</a></span>convert_utf32_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-8 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="ad868e852d46a46b631524f2a4bb5f31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad868e852d46a46b631524f2a4bb5f31d">&#9670;&nbsp;</a></span>convert_utf32_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-8 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="ac9c2c1418f08f84e36c22727879db307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c2c1418f08f84e36c22727879db307">&#9670;&nbsp;</a></span>convert_utf8_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into latin1 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="ae845d016f715c25475970c4dfcb58a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae845d016f715c25475970c4dfcb58a8d">&#9670;&nbsp;</a></span>convert_utf8_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into latin1 string. </p>
<p>with errors</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a0eb08f6b1d102dd298f3d265615b21aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb08f6b1d102dd298f3d265615b21aa">&#9670;&nbsp;</a></span>convert_utf8_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16BE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="ae18e1b44673966d2f058524700d41db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18e1b44673966d2f058524700d41db0">&#9670;&nbsp;</a></span>convert_utf8_to_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16BE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a487615c5d6dc00183fdf6a904bd829dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487615c5d6dc00183fdf6a904bd829dc">&#9670;&nbsp;</a></span>convert_utf8_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16LE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a6091f1fbcaf897575af907ab8896d151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6091f1fbcaf897575af907ab8896d151">&#9670;&nbsp;</a></span>convert_utf8_to_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16LE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="aab894ce236190e9cc71e0ce1602bbc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab894ce236190e9cc71e0ce1602bbc60">&#9670;&nbsp;</a></span>convert_utf8_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-32 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a5c5166f22c16902452eec6a93ad7a926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5166f22c16902452eec6a93ad7a926">&#9670;&nbsp;</a></span>convert_utf8_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-32 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="a6896e27fd7fe773ba25bfaed081aafaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6896e27fd7fe773ba25bfaed081aafaa">&#9670;&nbsp;</a></span>convert_valid_utf16be_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16be_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16BE string into Latin1 string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a15e91ad7be0d09f713283d33105a4939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e91ad7be0d09f713283d33105a4939">&#9670;&nbsp;</a></span>convert_valid_utf16be_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16be_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into UTF-32BE string. </p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a204aff56bf36d384694a5b5e73ddc579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204aff56bf36d384694a5b5e73ddc579">&#9670;&nbsp;</a></span>convert_valid_utf16be_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16be_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16BE string into UTF-8 string. </p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a65c8a9e58f4c111d52851e4fdbca0af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c8a9e58f4c111d52851e4fdbca0af1">&#9670;&nbsp;</a></span>convert_valid_utf16le_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16le_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into Latin1 string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a2bd5db8c4f3f4b6055497138f8cec860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd5db8c4f3f4b6055497138f8cec860">&#9670;&nbsp;</a></span>convert_valid_utf16le_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16le_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into UTF-32 string. </p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a3d5ab12b92ea57e2b88af5b19118833b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5ab12b92ea57e2b88af5b19118833b">&#9670;&nbsp;</a></span>convert_valid_utf16le_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16le_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into UTF-8 string. </p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a00b1ec570f19982c826e2b04b501a1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b1ec570f19982c826e2b04b501a1ac">&#9670;&nbsp;</a></span>convert_valid_utf32_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into Latin1 string. </p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a38557c96a34c9cc87f7294aca0538582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38557c96a34c9cc87f7294aca0538582">&#9670;&nbsp;</a></span>convert_valid_utf32_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into UTF-16BE string. </p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a9f8ccb48c01e7f93480e9bdd7fb3beee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8ccb48c01e7f93480e9bdd7fb3beee">&#9670;&nbsp;</a></span>convert_valid_utf32_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into UTF-16LE string. </p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a5d859ac6b4327e3155f1accef2f42c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d859ac6b4327e3155f1accef2f42c23">&#9670;&nbsp;</a></span>convert_valid_utf32_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into UTF-8 string. </p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a903279159cb5f5e0e767cce6f1440889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903279159cb5f5e0e767cce6f1440889">&#9670;&nbsp;</a></span>convert_valid_utf8_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into latin1 string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a8d655f7769c5e5039821d512c116dc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d655f7769c5e5039821d512c116dc56">&#9670;&nbsp;</a></span>convert_valid_utf8_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into UTF-16BE string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

</div>
</div>
<a id="a08870586c80a46861a25c715323402c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08870586c80a46861a25c715323402c1">&#9670;&nbsp;</a></span>convert_valid_utf8_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into UTF-16LE string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

</div>
</div>
<a id="a7566c1718e91a6d36b0c47822b0154ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7566c1718e91a6d36b0c47822b0154ad">&#9670;&nbsp;</a></span>convert_valid_utf8_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into UTF-32 string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char32_t </dd></dl>

</div>
</div>
<a id="ad80712666d56ad7abb7cd8ea7862a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80712666d56ad7abb7cd8ea7862a4dd">&#9670;&nbsp;</a></span>count_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::count_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of code points (characters) in the string assuming that it is valid. </p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="a612381e291d6a957707defcba3c5d4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612381e291d6a957707defcba3c5d4aa">&#9670;&nbsp;</a></span>count_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::count_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of code points (characters) in the string assuming that it is valid. </p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="a380f5ef4b282ef66210a84ebc84bce51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380f5ef4b282ef66210a84ebc84bce51">&#9670;&nbsp;</a></span>count_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::count_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of code points (characters) in the string assuming that it is valid. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="a147dfc3a2a525074a863374ea9ea8c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147dfc3a2a525074a863374ea9ea8c09">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; simdutf::implementation::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The description of this implementation. </p>
<pre class="fragment">const implementation *impl = simdutf::active_implementation;
cout &lt;&lt; "simdutf is optimized for " &lt;&lt; impl-&gt;name() &lt;&lt; "(" &lt;&lt; impl-&gt;description() &lt;&lt; ")" &lt;&lt; endl;
</pre> <dl class="section return"><dt>Returns</dt><dd>the name of the implementation, e.g. "haswell", "westmere", "arm64" </dd></dl>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l01348">1348</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>

</div>
</div>
<a id="ad4a7dbe2fbc9d03da2542c07a88cdddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a7dbe2fbc9d03da2542c07a88cdddb">&#9670;&nbsp;</a></span>detect_encodings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int simdutf::implementation::detect_encodings </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will try to detect the possible encodings in one pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the string to identify </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoding type detected </dd></dl>

</div>
</div>
<a id="a6936dace0dfd89741259cdbe49b5df2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6936dace0dfd89741259cdbe49b5df2d">&#9670;&nbsp;</a></span>latin1_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::latin1_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-32 string would require in Latin1 format. </p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as Latin1 </dd></dl>

</div>
</div>
<a id="a2cc04b416c87dfa742056ce5bd8033dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc04b416c87dfa742056ce5bd8033dc">&#9670;&nbsp;</a></span>latin1_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::latin1_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-8 string would require in Latin1 format. </p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-8 string as Latin1 </dd></dl>

</div>
</div>
<a id="a3281cf45b997303c89cf2d462d85d384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3281cf45b997303c89cf2d462d85d384">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; simdutf::implementation::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of this implementation. </p>
<pre class="fragment">const implementation *impl = simdutf::active_implementation;
cout &lt;&lt; "simdutf is optimized for " &lt;&lt; impl-&gt;name() &lt;&lt; "(" &lt;&lt; impl-&gt;description() &lt;&lt; ")" &lt;&lt; endl;
</pre> <dl class="section return"><dt>Returns</dt><dd>the name of the implementation, e.g. "haswell", "westmere", "arm64" </dd></dl>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l01338">1338</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>

</div>
</div>
<a id="a6cd8f7d8787c76e690ed9c4151abb7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd8f7d8787c76e690ed9c4151abb7a9">&#9670;&nbsp;</a></span>supported_by_runtime_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool simdutf::implementation::supported_by_runtime_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The instruction sets this implementation is compiled against and the current CPU match. </p>
<p>This function may poll the current CPU/system and should therefore not be called too often if performance is a concern.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the implementation can be safely used on the current system (determined at runtime) </dd></dl>

</div>
</div>
<a id="a4b211eefd837bfb9c080df56c408c3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b211eefd837bfb9c080df56c408c3d4">&#9670;&nbsp;</a></span>utf16_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf16_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of bytes that this UTF-16 string would require in Latin1 format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16 string as Latin1 </dd></dl>

</div>
</div>
<a id="a3761299ce52ee8b2b480fcadc50b45a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3761299ce52ee8b2b480fcadc50b45a5">&#9670;&nbsp;</a></span>utf16_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf16_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of two-byte code units that this UTF-32 string would require in UTF-16 format. </p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as UTF-16 </dd></dl>

</div>
</div>
<a id="ae01141d4bf774c95e771924caa11efb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01141d4bf774c95e771924caa11efb1">&#9670;&nbsp;</a></span>utf16_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf16_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of 2-byte code units that this UTF-8 string would require in UTF-16LE format. </p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of char16_t code units required to encode the UTF-8 string as UTF-16LE </dd></dl>

</div>
</div>
<a id="a8039edd257c0f2bdf1acc5d16476992a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8039edd257c0f2bdf1acc5d16476992a">&#9670;&nbsp;</a></span>utf32_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf32_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of bytes that this UTF-32 string would require in Latin1 format. </p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as Latin1 </dd></dl>

</div>
</div>
<a id="a39bc047dd50ede9cd33cb7e825eb5b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bc047dd50ede9cd33cb7e825eb5b56">&#9670;&nbsp;</a></span>utf32_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf32_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of 4-byte code units that this UTF-8 string would require in UTF-32 format. </p>
<p>This function is equivalent to count_utf8.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of char32_t code units required to encode the UTF-8 string as UTF-32 </dd></dl>

</div>
</div>
<a id="aff358bb1f0b909cd1e9a6227656ee5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff358bb1f0b909cd1e9a6227656ee5d7">&#9670;&nbsp;</a></span>utf8_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of bytes that this Latin1 string would require in UTF-8 format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the Latin1 string as UTF-8 </dd></dl>

</div>
</div>
<a id="abce2ef1ff8ab5ffd3999d545f703a2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce2ef1ff8ab5ffd3999d545f703a2fd">&#9670;&nbsp;</a></span>utf8_length_from_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-16BE string would require in UTF-8 format. </p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16BE string as UTF-8 </dd></dl>

</div>
</div>
<a id="a446248e71fc872b071d25a27673139f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446248e71fc872b071d25a27673139f5">&#9670;&nbsp;</a></span>utf8_length_from_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-16LE string would require in UTF-8 format. </p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16LE string as UTF-8 </dd></dl>

</div>
</div>
<a id="a2f39ff7d49c8864a9035c626825edad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f39ff7d49c8864a9035c626825edad0">&#9670;&nbsp;</a></span>utf8_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-32 string would require in UTF-8 format. </p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as UTF-8 </dd></dl>

</div>
</div>
<a id="adde94939db547675113aa71ec979d2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde94939db547675113aa71ec979d2ce">&#9670;&nbsp;</a></span>validate_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_ascii </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the ASCII string. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the ASCII string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid ASCII. </dd></dl>

</div>
</div>
<a id="aa73e0b4e751f59a6f67c0bde3e503e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73e0b4e751f59a6f67c0bde3e503e23">&#9670;&nbsp;</a></span>validate_ascii_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_ascii_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the ASCII string and stop on error. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the ASCII string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a27a221cf4c4d195d110387d10bbd4b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a221cf4c4d195d110387d10bbd4b33">&#9670;&nbsp;</a></span>validate_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16BE string. </p>
<p>This function may be best when you expect the input to be almost always valid. Otherwise, consider using validate_utf16be_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16BE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16BE. </dd></dl>

</div>
</div>
<a id="a7632c87e825c7f268cbb787612e940bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7632c87e825c7f268cbb787612e940bf">&#9670;&nbsp;</a></span>validate_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16BE string and stop on error. </p>
<p>It might be faster than validate_utf16be when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16BE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a6047ac139bd2e8f6808a5bbd4b687629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6047ac139bd2e8f6808a5bbd4b687629">&#9670;&nbsp;</a></span>validate_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16LE string.This function may be best when you expect the input to be almost always valid. </p>
<p>Otherwise, consider using validate_utf16le_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16LE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16LE. </dd></dl>

</div>
</div>
<a id="a53ce751bb24df472a93e4c36e8a1b03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ce751bb24df472a93e4c36e8a1b03d">&#9670;&nbsp;</a></span>validate_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16LE string and stop on error. </p>
<p>It might be faster than validate_utf16le when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16LE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="ab35c6765b2e4b97cc97ab9f3af52c9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35c6765b2e4b97cc97ab9f3af52c9a9">&#9670;&nbsp;</a></span>validate_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-32 string. </p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-32 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 4-byte code units (char32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-32. </dd></dl>

</div>
</div>
<a id="a825ad7513447a16cd12f5425e2e88431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825ad7513447a16cd12f5425e2e88431">&#9670;&nbsp;</a></span>validate_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-32 string and stop on error. </p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-32 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 4-byte code units (char32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="aaae969eb20db2099f92a504eb7db0bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae969eb20db2099f92a504eb7db0bcf">&#9670;&nbsp;</a></span>validate_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-8 string. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-8 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-8. </dd></dl>

</div>
</div>
<a id="a42f53d3a9e9112a7ad4dfe67cfeccf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f53d3a9e9112a7ad4dfe67cfeccf07">&#9670;&nbsp;</a></span>validate_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-8 string and stop on errors. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-8 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/simdutf/<a class="el" href="implementation_8h_source.html">implementation.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>simdutf</b></li><li class="navelem"><a class="el" href="classsimdutf_1_1implementation.html">implementation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
